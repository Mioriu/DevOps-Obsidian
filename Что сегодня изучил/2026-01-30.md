Практиковался с докер. Решал задачу по сетям, по подключению контейнеров к одной сети и обмене трафиком между ними.
---
Type: Task
Priority: High
Assignee: [Твое имя]
Tags: #docker #network #container #postgres #nginx
Status: done
Date: 2025-01-30
---

# Развернуть веб-приложение с отдельным контейнером БД в изолированной сети

## Summary
Развернуть веб-приложение с отдельным контейнером БД в изолированной сети

## Description
1. Создай пользовательскую сеть Docker с именем `my-app-network` и драйвером `bridge`.
2. Запусти контейнер с СУБД PostgreSQL:
   - Используй образ `postgres:15-alpine`
   - Имя контейнера: `postgres-db`
   - Подключи его к сети `my-app-network`
   - Задай переменные окружения:
        POSTGRES_USER=myuser
        POSTGRES_PASSWORD=mypassword
        POSTGRES_DB=mydb
   - Запусти в фоновом режиме
3. Запусти контейнер с веб-приложением:
   - Используй образ `nginx:alpine`
   - Имя контейнера: `web-app`
   - Подключи его к той же сети `my-app-network`
   - Пробрось порт 80 контейнера на порт 8888 хоста
   - Запусти в фоновом режиме
4. Проверь:
   a) Что оба контейнера запущены и подключены к одной сети
   b) Что `web-app` может разрешить имя `postgres-db` (ping по имени)
   c) Что `postgres-db` доступен из `web-app` по порту 5432 (проверь через telnet или nc)
   d) Что веб-сервер доступен с хоста по `localhost:8888`
5. *Дополнительно*: Подключись к контейнеру `postgres-db` и создай простую таблицу для проверки работоспособности.

## Ограничения
- Не используй дефолтную сеть (bridge)
- Все взаимодействия между контейнерами должны происходить по именам контейнеров (не по IP)
- Для проверки связи используй команды внутри контейнеров (exec)

## Практическое задание
### Выполненные команды

```bash
# 1. Создание сети
docker network create --attachable --driver=bridge my-app-network

# 2. Запуск PostgreSQL
docker run -d \
  --name=postgres-db \
  --network=my-app-network \
  -e POSTGRES_USER="myuser" \
  -e POSTGRES_PASSWORD="mypassword" \
  -e POSTGRES_DB="mydb" \
  postgres:15-alpine

# 3. Запуск Nginx
docker run -d \
  --name=web-app \
  --network=my-app-network \
  -p 8888:80 \
  nginx:alpine

### Результаты проверок

#### 4a) Проверка сети

bash

docker inspect web-app | grep Network
docker inspect postgres-db | grep Network

Оба контейнера подключены к `my-app-network`

#### 4b) Проверка разрешения имён

bash

docker exec web-app ping -c 4 postgres-db

✅ 4 пакета получено, 0 потеряно

#### 4c) Проверка доступности порта 5432

bash

docker exec web-app nc -zv postgres-db 5432

✅ Порт открыт

#### 4d) Проверка доступа с хоста

bash

curl localhost:8888

✅ Возвращается `index.html`, страница корректно отображается в браузере

### 5) Дополнительная проверка

bash

# Подключение к PostgreSQL
docker exec -it postgres-db psql -U myuser -d mydb

# В интерактивной сессии psql:
CREATE TABLE test (id numeric);
INSERT INTO test VALUES (1);
SELECT * FROM test;

✅ Таблица создана, данные записываются и читаются корректно

## Проверочные вопросы

### 1. Аргумент --attachable

Использовал ошибочно. Параметр `--attachable` нужен только в контексте Docker Swarm и оверлейных сетей. Без него в данном сценарии (без Swarm) сеть работала бы корректно, так как контейнеры подключаются при создании.

### 2. DNS в пользовательских сетях

Docker имеет встроенный DNS-сервер для пользовательских сетей, который автоматически разрешает имена контейнеров в IP-адреса. Если создать второй контейнер `postgres-db2` в той же сети, `web-app` сможет обратиться к нему по имени.

### 3. Изоляция сети

**Дефолтная сеть bridge (docker0):**

- Контейнеры могут общаться только по IP
    
- Меньшая изоляция между контейнерами
    
- Нет автоматического разрешения имён (требуется `--link`, устарел)
    

**Пользовательская сеть bridge:**

- Автоматическое разрешение имён контейнеров
    
- Лучшая изоляция (контейнеры в разных сетях не видят друг друга)
    
- Более предсказуемые правила iptables
    
- Возможность настройки подсети, шлюза, MTU
    

### 4. Доступность портов

Порт 5432 не требуется пробрасывать на хост (-p 5432:5432), потому что контейнеры в одной пользовательской сети Docker видят все порты друг друга (как они открыты внутри контейнера). Проброс портов нужен только для доступа с хоста или извне. Контейнеры общаются по внутренним портам (`web-app:80`, `postgres-db:5432`).

### 5. Безопасность и доступ извне

**Способы предоставить доступ к БД внешним приложениям:**

1. **Проброс порта на хост** (самый простой):
    
    bash
    
    docker run -p 5432:5432 ...
    
    Но открывает порт всему миру.
    
2. **Использование reverse proxy** (рекомендуется):
    
    - Запустить nginx/haproxy в той же сети
        
    - Проксировать запросы к PostgreSQL через SSL/TLS
        
    - Не открывать порт 5432 напрямую
        
3. **API Gateway / Service Mesh**:
    
    - Использовать Traefik, Kong или подобные решения
        
    - Контролировать доступ через авторизацию
        
4. **Docker Compose с selective ports**:  
    Указать `ports` только для нужных сервисов в `docker-compose.yml`
    
5. **Оверлейные сети для кластера**:  
    Для доступа между контейнерами на разных хостах в Swarm/Kubernetes, но не для внешнего доступа сам по себе.
