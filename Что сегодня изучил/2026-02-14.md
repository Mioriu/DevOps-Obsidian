Сегодня продолжил изучать процессы

Подробнее изучил состояние процессов
R(running) - процесс выполняется
S(sleeping) - процесс ожидает команды
T(stopped) - процесс остановлен
D(uninterruptible sleep) - непрерываемое ожидание
Z(zombie) - Когда процесс убит, но остается в списке, родительский процесс еще не получил сигнал о завершении такого процесса
I(idle) - для потоков ядра

Так же еще бывают процессы сироты(Orphaned) -  у которых завершился родительский процесс и они переходят под контроль другого, обычно 1 или systemd

Просмотр состояний:
ps aux
ps -eo pid,state
top,htop

Изучал мониторинг процессов - очень важная вещь, помогает следить и управлять ресурсами системы, отслеживать проблемные места и точки оптимизации
Для мониторинга различных ресурсов вплоть до i/o дисков(iostat) есть различные утилиты.
Самые основные это
ps aux - для просмотра всех процессов, а так же возможности сортировать по цпу, памяти и т.д (ps -eo pid,comm,%mem --sort=-%mem)
top или более улучшенная версия htop - для отслеживания процессов в реальном времени(task manager), позволяет сортировать, останавливать процессы
pstree - для просмотра дерева процессов
Остальные утилиты ситуативны, но их очень много pidstat,dstat,vmstat,iostat и так далее

Познакомился с сигналами в линукс. С помощью сигналов можно управлять процессами, а именно останавливать принудительно, завершать штатно, возобновлять, передавать пользовательские сигналы(SGIUSR1, SIGUSR2) и так далее
Весь список сигналов можно посмотреть с помощью kill -l
У них есть как числовые айди по которым их можно вызывать, так и текстовые SIGKILL, SIGTERM и т.д. Все их можно передавать через команду kill, kill -9 PID, kill -SIGCONT PID - для возобновления процесса.
Интересным мне показался -1 или SIGHUP, который позволяет обновлять конфигурации например у веб-серверов kill -1 $(pidof nginx)
Так же сигналы можно передавать в баш скриптах через команду trap
trap 'echo "Получен сигнал завершения"; exit' SIGTERM SIGINT

Познакомился с метрикой LA, load average, которая является очень важный показателем для определения нагрузки на систему.
Вывести ее можно через команды:
uptime
top,htop - увидим наверху.
Представляет из себя три числа 0.0 0.0 0.0 и показывает среднее количество работающих и ожидающих процессов за 1,5,15 минут.
Например, если минуту делим на 2 интервала по 30 секунд, за первые 30 секунд работало/ожидало 2 процесса, за вторые 6, в таком случае la составит (2+6)/2 = 4, если например делим на 3 интервала по 20 секунд, и в первые 20 работало 2 процесса, вторые 0, третьи 6, то LA составит (2+0+6)/3 = 2.67 - хоть и процессов за минуту столько же, как я понял считаются процессы именно в определенные интервалы
Нормальная LA нагрузка зависит от ядер и можно показать возрастание или снижение нагрузки, проверяем количество процессоров(ядер) grep -c ^processor /proc/cpuinfo
если у нас одно, то нормальной нагрузкой является LA до единцы, это значит что ничего не тормозит и процессы не встают в очередь, если LA будет 1.0 1.0 1.0 , значит используется 100% процессора(4.0 например для 4х) если больше единицы, значит процессы встают в очередь и система будет тормозить.
Если например за первую минуту 2.5 1.5 1.0 больше остальных значит нагрузка начинает возрастать, если меньше 1.0 1.5 2.0 значит нагрузка снижается, если примерно одинаково значит нагрузка стабильна

Так же узнал о приоритетах процессов, а именно их можно повышать и снижать от -20 до +19, где -20 - самый высокий приоритет, а +19 самый низкий(повышать приоритет можно только под root правами)
Запуск с измененным приоритетом nice -n 15 ./csript.sh
изменение - renice -n 19 ./script.sh
Так же есть realtime приоритеты,(0-99) которые редко используются, для в основном для обработки звука или видео меняются следующим образом
chrt -f 80 ./scr.sh
chrt -p PID - просмотр

[[Состояния процессов]] [[Мониторинг процессов]] [[Сигналы в линукс]] [[Load Average]] [[Приоритеты процессов]]
