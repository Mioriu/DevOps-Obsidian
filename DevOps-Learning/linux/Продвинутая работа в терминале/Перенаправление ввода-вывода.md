В Linux одна из самых мощных и полезных возможностей терминала — это перенаправление ввода и вывода. Оно позволяет вам управлять потоками данных: записывать результат выполнения команд в файл, использовать содержимое файлов в качестве ввода для команд или передавать результат одной команды другой.

### Стандартные потоки ввода-вывода

Любая команда в терминале по умолчанию имеет три стандартных потока данных:

- **STDIN (стандартный ввод)** — данные, которые поступают на вход команде (обычно с клавиатуры).
- **STDOUT (стандартный вывод)** — данные, которые выводит команда при успешном выполнении (обычно на экран).
- **STDERR (стандартный поток ошибок)** — ошибки и предупреждения, выводимые командой (также обычно на экран).

> STDIN — 0    
> STDOUT — 1    
> STDERR — 2

Эти потоки вы можете направлять по своему усмотрению, используя специальные символы перенаправления.

### Перенаправление вывода в файл (STDOUT)

Чтобы сохранить вывод команды в файл, используйте символ `>`:

```bash
ls -l > files.txt
```

- Команда выше не покажет результат на экране, а запишет его в файл `files.txt`.
- Будьте внимательны: если файл уже существует, его содержимое будет перезаписано.

Если же вы хотите **добавить** результат команды в конец файла, используйте символ `>>`:

```bash
date >> files.txt
```

### Перенаправление ошибок (STDERR)

Если вы хотите записать ошибки команды в отдельный файл, используйте `2>`:

```bash
ls /несуществующая_папка 2> errors.txt
```

Таким образом ошибки будут сохранены в файле `errors.txt`, а не показаны на экране.

### Перенаправление сразу нескольких потоков (STDOUT и STDERR)

Часто бывает нужно записать и результат, и ошибки в отдельный файл. Для этого используется конструкция:

```1c
команда > файл 2>&1
```

- `> файл` — перенаправляет стандартный вывод в файл.
- `2>&1` — перенаправляет ошибки (STDERR, поток номер 2) туда же, куда направлен стандартный вывод (STDOUT, поток номер 1).

**Пример:**

```bash
ls /etc /несуществующая_папка > output.txt 2>&1
```

Теперь в `output.txt` попадёт и список файлов из `/etc`, и сообщение об ошибке, если папка не найдена.

#### Другой вариант перенаправления обоих потоков

Существует альтернативный (и более современный) способ записи обоих потоков в один файл с помощью `&>`:

```bash
ls /etc /несуществующая_папка &> full_output.txt
```

Эта конструкция работает аналогично предыдущему примеру.

### Перенаправление ввода из файла (STDIN)

Вы можете подавать содержимое файла на вход команде с помощью символа `<`:

```bash
sort < unsorted.txt
```

- Эта команда сортирует строки файла `unsorted.txt` и выведет результат на экран.

### Конвейеры (pipes)

Конвейеры — это способ соединения нескольких команд, при котором вывод одной команды становится входом для следующей. Символ конвейера — вертикальная черта `|`:

```bash
ls -l | less
```

- Эта команда берёт список файлов из текущей директории и отправляет его на вход команде `less`, которая покажет его постранично.
- Конвейеры можно комбинировать в длинные цепочки:
    
    ```bash
    cat logfile.txt | grep ERROR | sort | uniq -c
    ```
    

### Ещё примеры перенаправления нескольких потоков

Рассмотрим ещё несколько практических примеров, чтобы закрепить понимание:

- **Отдельная запись STDOUT и STDERR в разные файлы**:
    
    ```lua
    find / -name "myfile.txt" > results.txt 2> errors.txt
    ```
    
    В этом случае успешные находки попадут в `results.txt`, ошибки доступа и т.п. — в `errors.txt`.
- **Отдельное перенаправление STDERR в никуда (отбросить ошибки)**:
    
    ```javascript
    grep "mytext" * 2>/dev/null
    ```
    
    Таким образом вы видите только успешные совпадения, а сообщения об ошибках (например, о доступе к файлам) будут скрыты.

### Краткое напоминание о перенаправлениях

- `>` — перезапись STDOUT в файл  
- `>>` — добавление STDOUT в файл 
- `2>` —запись STDERR в файл  
- `> файл 2>&1` или `&> файл` — записать STDOUT и STDERR в один файл
- `<` — использовать файл как STDIN
- `|` — соединить команды конвейером (STDOUT → STDIN)

Для записи stdout в файл можно использовать `>` (перезапись), `>>` (добавление) и `&>` (запись stdout+stderr вместе).

## Промежуточный итог

Используя перенаправление ввода-вывода, вы сможете лучше управлять результатами выполнения команд, сохранять их, обрабатывать и передавать дальше. Это один из ключевых навыков при работе в терминале Linux, и именно благодаря ему терминал становится таким мощным и гибким инструментом.

## Перенаправление ввода-вывода — расширенные возможности

Давайте изучим более продвинутые и мощные возможности: комбинирование потоков, отправку данных в несколько направлений одновременно, а также работу с командой **tee** и другие полезные техники.

```bash
command | tee file1 file2
```

### Комбинированное перенаправление

Иногда бывает нужно отправить стандартный вывод и ошибки в разные файлы одновременно. Для этого используется такая конструкция:

```lua
команда > output.txt 2> errors.txt
```

- Пример:
    
    ```bash
    find /etc -name "*.conf" > found_files.txt 2> errors.txt
    ```
    
    Таким образом, успешный вывод попадёт в `found_files.txt`, а сообщения об ошибках — в `errors.txt`.

### Отбрасывание нежелательных сообщений (отправка в /dev/null)

Иногда сообщения об ошибках не нужны совсем, и их можно просто отбросить, отправив в `/dev/null` — специальный файл, который всё «поглощает» и никогда не сохраняет:

```javascript
команда 2>/dev/null
```

- Пример:
    
    ```bash
    grep "password" /etc/* 2>/dev/null
    ```
    
    Теперь ошибки о доступе будут игнорироваться, и на экране останутся только полезные результаты.

### Отправка одного потока в несколько мест сразу (команда tee)

Команда **tee** используется для того, чтобы одновременно вывести результат на экран и сохранить его в файл:

```bash
команда | tee файл.txt
```

- Пример:
    
    ```bash
    ls -l /etc | tee etc_list.txt
    ```
    
    Таким образом, вы одновременно видите список файлов на экране и записываете его в файл `etc_list.txt`.

Если вы хотите добавить данные в уже существующий файл, используйте ключ `-a`:

```bash
команда | tee -a файл.txt
```

### Использование tee с перенаправлением ошибок

По умолчанию tee читает данные только из STDOUT. Чтобы перенаправить через tee ошибки (STDERR), нужно предварительно перенаправить STDERR в STDOUT:

```bash
команда 2>&1 | tee all_output.txt
```

- Пример:
    
    ```bash
    grep "username" /etc/* 2>&1 | tee search_results.txt
    ```
    
    Теперь все результаты (и ошибки, и обычный вывод) будут и на экране, и в файле `search_results.txt`.

### Перенаправление с помощью Here Document (<<)

С помощью конструкции **Here Document** вы можете отправить несколько строк на стандартный ввод команды без использования файла:

```bash
команда << EOF
строка 1
строка 2
EOF
```

- Пример создания файла с помощью Here Document:
    
    ```bash
    cat << EOF > newfile.txt
    Hello, world!
    This is a multiline text.
    EOF
    ```
    
    После этого будет создан файл `newfile.txt` с указанным текстом.

### Использование Here Strings (<<<)

С помощью конструкции **Here Strings** вы можете отправить короткий текстовый ввод на STDIN:

```bash
команда <<< "текстовая строка"
```

- Пример:
    
    ```perl
    grep "Linux" <<< "I love Linux and terminal!"
    ```
    
    Команда найдёт слово «Linux» в заданной строке.

### Краткое напоминание продвинутых техник

- `команда > output.txt 2> errors.txt` — отдельное перенаправление вывода и ошибок.
- `команда 2>/dev/null` — отбрасывание ошибок.
- `команда | tee file.txt` — вывод одновременно и на экран, и в файл.
- `команда 2>&1 | tee file.txt` — объединение потоков (вывод и ошибки) и запись их одновременно на экран и в файл.
- `команда << EOF` — передача нескольких строк на вход команды без промежуточного файла.
- `команда <<< "строка"` — быстрая передача короткой строки на STDIN.

## Итог

Продвинутые возможности перенаправления ввода-вывода позволяют вам тонко управлять потоками данных, эффективно решать практические задачи и строить сложные сценарии работы команд. В частности, с помощью команд **tee**, конструкций **Here Document** и **Here Strings**, вы получаете мощные инструменты для повседневной работы в терминале.

В следующем уроке мы закрепим все полученные знания на практике и увидим, как перенаправления используются в реальных рабочих ситуациях.